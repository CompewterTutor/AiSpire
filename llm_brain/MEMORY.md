# AiSpire Project Memory

## Project Overview
AiSpire is an MCP Server and plugin for Vectric Aspire/V-Carve (CAD/CAM Software). The system consists of a Lua "Gadget" that runs a socket server inside V-Carve with access to the Lua Gadget SDK, and a Python MCP Server that connects to it, enabling control by LLMs.

## Current Project State
- Initial project setup completed
  - Directory structure created with main folders for both components
  - Basic README.md created with project overview, architecture, and features
  - .gitignore file created for Lua and Python development
  - Coding standards document established in docs/CODING_STANDARDS.md
- Initial implementation of both components started:
  - Lua Gadget: Basic socket server with command processing framework
  - Python MCP Server: Basic server structure with Lua client implementation
- Project architecture defined with two main components: Lua Gadget and Python MCP Server
- Communication protocol between components designed using JSON message format
- JSON parsing implementation completed for Lua component
  - Custom JSON encoder/decoder created for Lua
  - Comprehensive test suite implemented for JSON module
- Testing frameworks set up for both components
  - Lua: Busted framework configured with test runner
  - Python: pytest with asyncio support configured
- Helper functions for common operations implemented:
  - Path creation and manipulation (circles, rectangles, polygons)
  - Path combining using boolean operations
  - Path offsetting and scaling
  - Vector drawing (lines, arcs, curves, polylines)
  - Text creation and styling
  - Dimension and measurement tools
  - Toolpath creation (profile, pocket, drilling, 3D roughing and finishing)
  - 3D model import and manipulation
    - Model import from various file formats
    - Basic shape generation (cube, cylinder, sphere)
    - Model transformation (scale, rotate, position)
    - Model positioning with alignment options
    - Model combination with boolean operations
    - Model export to various formats
  - Vector nesting capabilities
    - Multiple nesting algorithms (bottom-left packing, genetic algorithm)
    - Support for rotation optimization
    - Material utilization reporting
    - Configurable spacing and material dimensions
- Advanced features implemented:
  - Timeout mechanism for long-running Lua code execution
  - Logging system with configurable verbosity levels
  - Configuration management via config files
  - Runtime configuration changes support
  - Configuration validation
  - Server module refactoring for both Vectric and standalone usage
    - Extracted server code into a separate module (server.lua)
    - Created standalone runner with mock Vectric SDK (run_standalone_server.lua)
    - Implemented comprehensive mock objects for testing outside of Vectric
    - Added test functions to validate the SDK wrapper functionality
- Comprehensive documentation created for the Lua component:
  - Detailed API documentation with function parameters and return values
  - Usage examples for all helper functions
  - Complete workflow examples for common CAD/CAM operations
  - Troubleshooting guide with common issues and solutions
  - Code examples for reference
- Command generation system for Python MCP Server implemented:
  - Lua code generation templates for common operations
  - Command validation system with security checks
  - Command queueing system with priority support
  - Template engine for generating Lua code
  - Command status tracking and result handling
  - Tests for command generator and queue components
- Result parsing and formatting for Python MCP Server completed:
  - Parse JSON responses from Lua gadget
  - Format results according to MCP protocol
  - Added comprehensive support for handling different result types:
    - Success responses with formatted data and messages
    - Error responses with categorization and detailed information
    - In-progress responses for long-running operations
    - Informational and warning responses
  - Error categorization system to classify different errors
  - Response processing to standardize all outputs
  - Comprehensive testing for all response types and formats
- End-to-End testing framework implemented:
  - Mock Lua socket server that simulates the Lua Gadget
  - Mock Vectric SDK for testing without the actual software
  - Tests for socket communication between components
  - Tests for command execution flow
  - Tests for error handling and recovery
  - Test runner for running all end-to-end tests
  - Documentation for running tests
- No integration testing performed yet with actual Vectric software
- LLM integration implemented for Python MCP Server:
  - Created an LLMHandler class that processes requests from language models
  - Implemented handlers for different command types (execute_code, execute_function, query_state)
  - Added natural language request processing foundation
  - Integrated with existing MCP protocol implementation
  - Added comprehensive tests for the LLM handler
  - Updated MCP server to use the new handler
- Command templates for common operations implemented:
  - Job management templates for creating, opening, saving, and managing job properties
  - Vector creation and manipulation templates for shapes, text, and boolean operations
  - Toolpath generation templates for various toolpath types (profile, pocket, drilling, 3D operations)
  - Layer management templates for creating and organizing layers
  - All templates have comprehensive error handling and standardized response formatting
  - Unit tests created to validate template functionality
  - Organized in a clean, modular structure with proper documentation
- Vector templates improved with proper cloning method:
  - Fixed the transform_vectors method in VectorTemplates to use object's Clone() method
  - Previously was trying to use a non-existent CloneVector function
  - Ensured that vector transformations (move, rotate, scale, mirror) preserve original vectors
- Mock Vectric SDK implemented for testing:
  - Created comprehensive object model with proper inheritance
  - Implemented vector object classes (Circle, Contour, Polyline, Text) with Clone() methods
  - Added matrix transformation support (translation, rotation, scaling, mirror)
  - Implemented core SDK functions for job, vector, layer, and toolpath management
  - Created tests to validate mock SDK functionality, especially for vector transformations
  - Fixed matrix multiplication ordering to match expected behavior of the real SDK
- Build system enhanced with standalone executable capabilities:
  - Added build-mcp command in Makefile to create standalone MCP server executable using PyInstaller
  - Created build-all command to build both Lua Gadget bundle and Python MCP server executable
  - Set up INSTALL directory for distributable files
  - Updated clean target to remove build artifacts
  - Added PyInstaller to development dependencies
  - Implemented comprehensive build documentation in Makefile help
- UI for Vectric gadget implemented:
  - Created a dedicated UI manager module (ui_manager.lua)
  - Implemented log viewer with color-coded entries
  - Added command history panel with ability to save/load and replay commands
  - Implemented connection status display with visual indicators
  - Created confirmation dialog for disconnect operations
  - Added alert handling for critical issues (e.g., connection loss during command execution)
  - Integrated UI with server module using a clean API
  - Added secondary gadget action to directly access the UI control panel
  - Implemented responsive HTML-based UI using Vectric HTML_Dialog system

## Technical Decisions
- Two-component architecture: Lua Gadget and Python MCP Server
- Socket-based communication between components using TCP
- JSON message format for commands and responses
- MCP protocol for LLM integration
- Default port: 9876 for socket communication between Lua and Python
- Default port: 8765 for MCP server communication with LLMs
- Authentication via shared secret tokens for security
- Sandbox environment for executing Lua code securely
- Configuration management via environment variables and config files
  - Support for JSON and YAML configuration formats
  - Hot-reloading of configuration changes
  - Validation of configuration parameters
- Custom JSON implementation for Lua to avoid dependencies
- Test-driven development approach for critical components
- Modular helper function design for reusability and maintainability
- Comprehensive test coverage for helper functions using mock objects
- Timeout management for long-running operations with graceful termination
- Multi-level logging system with configurable output destinations
- Command generation using template-based approach:
  - Pre-defined templates for common operations
  - Support for custom templates
  - Security validation before execution
  - Priority-based command queueing
- Result handling with standardized response formatting:
  - Unified response structure for all result types
  - Error categorization system with 9 categories
  - Progress tracking for in-progress operations
  - Detailed error reporting with context information
  - Response transformation between Lua and MCP protocols
- End-to-end testing approach:
  - Mock components for testing without actual Vectric software
  - Comprehensive test coverage for communication flow
  - Modular test organization for different aspects of functionality
  - Automated test runner for continuous integration
- Vector cloning using object's Clone() method:
  - All Vectric vector objects appear to have their own Clone() method
  - Using this approach preserves original vectors during transformations
- Deployment strategy with both distributable formats:
  - Vectric gadget file (.gadget) for Lua component
  - Standalone executable for Python MCP server
  - Combined build process with make build-all command
- UI implementation using Vectric's HTML_Dialog:
  - HTML/CSS/JavaScript-based UI for better customization
  - Tab-based interface for better organization
  - Event-driven architecture for UI updates
  - Consistent styling matching Vectric's visual design
  - Direct integration with server and logging subsystems

## Research Notes
- Vectric Aspire/V-Carve Lua SDK offers extensive functionality:
  - Job management (create, open, save, export)
  - Vector operations (create/modify geometric primitives)
  - Layer management
  - Toolpath operations
  - 3D modeling capabilities
  - UI operations (dialogs, messages)
- Lua socket implementation using LuaSocket library
- MCP protocol implementation in Python
- Detailed SDK stubs from vectric_lua_sdk_stubs.lua available for reference
- SDK objects for vector manipulation identified:
  - Contour: For path creation and manipulation
  - Circle, Polyline, BezierCurve: For specific vector types
  - Text: For text creation and styling
  - Group: For organizing multiple objects
  - Transformation2D: For transforming objects
- Toolpath creation capabilities identified in SDK:
  - Profile toolpaths for cutting along paths
  - Pocket toolpaths for clearing material
  - Drilling operations for hole creation
  - 3D roughing and finishing toolpaths for 3D models
- SDK object methods observed:
  - Many objects (like Contour) have their own Clone() method
  - This allows for creating working copies of objects without modifying originals
- UI capabilities in Vectric SDK:
  - HTML_Dialog supports full HTML/CSS/JavaScript customization
  - Dialog event handling for interactive UI components
  - Field value getting/setting for form elements
  - File selection dialogs for loading/saving files
  - MessageBox for simple notifications
  - ProgressBar for long-running operations

## Development Environment
- Need to set up:
  - Lua 5.3+ development environment with LuaSocket
  - Python 3.8+ environment with appropriate libraries
  - Testing frameworks for both components (Busted for Lua, pytest for Python)

## Current Challenges
- No official documentation for Vectric Lua SDK found yet, relying on SDK stubs
- Testing the Lua implementation without Vectric software requires mock SDK
- Need to implement command templates for common operations
- Ensuring secure execution of arbitrary Lua code in production environment
- Creating realistic mock objects for testing helper functions

## Next Steps
1. Implement performance metrics
2. Create alerts for critical issues
3. Create documentation for Python component
4. Test with mock Vectric SDK
5. Implement Vectric SDK wrapper functions for:
   - Job management functions (create, open, save, export)
   - Vector creation and manipulation functions
   - Toolpath creation and calculation functions
   - Layer management functions

## Resources
- SDK stubs from vectric_lua_sdk_stubs.lua
- Detailed Vectric SDK reference available at docs/vectric_sdk/Vectric.lua providing comprehensive API documentation
- Need to locate official Vectric Aspire/V-Carve SDK documentation
- Need to review MCP protocol specifications

## Notes for Future Development
- Consider implementing a command history system for undoing operations
- Plan for visualization of results from Python side
- Design should allow for future web UI integration
- Consider security implications of executing arbitrary Lua code
- Plan for testing without requiring actual Vectric software installation
- Create a comprehensive library of example operations for common CAD/CAM tasks
- Consider implementing a higher-level DSL for defining complex operations
- Investigate possible integration with other CAD/CAM formats and standards